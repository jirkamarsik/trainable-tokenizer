#ifndef INCLUDE_GUARD_COMMON_H
#define INCLUDE_GUARD_COMMON_H

#include <string>
#include <istream>

/* My own coding of the rough lexer token types. This removes a dependency
 * on Quex's native token type ids and makes the application more robust
 * and more easily modified. */
enum rough_token_id {
	TERMINATION,
	TOKEN_PIECE,
	MAY_BREAK_SENTENCE,
	MAY_SPLIT,
	MAY_JOIN,
	WHITESPACE,
	LINE_BREAK,
	PARAGRAPH_BREAK
};

/* My stripped down version of a rough token as reported by Quex. I use my
 * own data type so my code can rely on definitions which aren't generated during
 * runtime by Quex. If type_id == TOKEN_PIECE, the text member holds a UTF-8
 * STL string.*/
struct rough_token_t {
	rough_token_id type_id;
	std::string text;
};

/* An interface to the wrapper of the generated lexer. This definition lets
 * me access the generated rough lexers using the same type signature thanks
 * to polymorphism. */
class IRoughLexerWrapper {
public:
	// Reconstructs the lexer and points to a new source of data without
	// having to call the factory function.
	virtual void reset(std::istream *in, char const *encoding, bool byte_order_reversion) = 0;
	// Returns the next token generated by the input. Undefined behaviour
	// after sending the first token with type_id == TERMINATION.
	virtual rough_token_t receive() = 0;
};

#endif
