#include <iconv.h>
#include <stdexcept>
#include <cerrno>

#include "Encoder.hpp"
#include "configuration.hpp"

namespace trtok {

void Encoder::do_work() {
	iconv_t cd = iconv_open(m_output_encoding.c_str(), "UTF-8");
	if (cd == iconv_t(-1))
		throw std::invalid_argument("The specified encoding is not supported.");

	const size_t in_buffer_size = ENCODER_BUFFER_SIZE;
	const size_t out_buffer_size = ENCODER_BUFFER_SIZE * 4;

	char in_buffer[in_buffer_size];
	char *in_buffer_end = in_buffer + in_buffer_size;
	char out_buffer[out_buffer_size];
	
	// Where to are new bytes read?
	char *in_read_p = in_buffer;
	// Where are the bytes to be converted?
	char *in_conv_p = in_buffer;
	// How many bytes are there to convert?
	size_t in_bytes_ready = 0;
	// Where to store the conversion output?
	char *out_p = out_buffer;
	// How much space is there for conversion output?
	size_t out_bytes_left = out_buffer_size;

	// We convert while there is something to read or we have
	// leftovers in the input buffer.
	while (*m_input_stream_p || (in_read_p != in_buffer)) {
		if (*m_input_stream_p) {
			m_input_stream_p->read(in_read_p, in_buffer_end - in_read_p);
			in_bytes_ready += m_input_stream_p->gcount();
		}

		in_conv_p = in_buffer;
		out_p = out_buffer;
		out_bytes_left = out_buffer_size;
		size_t converted = iconv(cd, &in_conv_p, &in_bytes_ready, &out_p, &out_bytes_left);
		if ((converted == -1) && (errno == EILSEQ)) {
			// TODO: Remove this check because we can be sure that
			// a) the UTF-8 sequences are generated by us and therefore
			//    are noise-free
			// b) the target encoding is the same as the source encoding
			//    (for the whole program) so we should never have to output
			//    a value impossible for the target encoding
			// Hence this occurs only when using the Encoder outside
			// the final program on foreign input.
			std::string bad_sequence;
			bad_sequence.push_back(*in_conv_p++);
			// We read all the continuation bytes (10xxxxxx) along with
			// the first byte of the invalid sequence.
			while ((in_conv_p != in_buffer_end) && (*in_conv_p >> 6 == 2))
				bad_sequence.push_back(*in_conv_p++);
			throw std::logic_error("Encountered character (" + bad_sequence + ") invalid for target encoding.");
		}
		m_output_stream_p->write(out_buffer, out_p - out_buffer);

		// There might have been leftovers at the end of the input buffer
		// which weren't processed by the converter either due to not enough
		// space in the output buffer or the input was trailed by an incomplete
		// multibyte sequence. We "read" (copy) these leftovers from the rest
		// of the buffer to its beginnig.
		char* in_copy_p = in_conv_p;
		in_read_p = in_buffer;
		while (in_copy_p != in_conv_p + in_bytes_ready) {
			*in_read_p++ = *in_copy_p++;
		}
	}

	iconv_close(cd);

	m_output_stream_p->flush();
}

}
